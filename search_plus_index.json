{"./":{"url":"./","title":"勤劳的螺丝工","keywords":"","body":"勤劳的螺丝工 记录遇到的问题与解决方式...分享我的知识、经历和观点... 个人简介： 个人标签：勤劳的螺丝工，后端资深CV攻城狮，golang深度中毒者...联系邮箱：zhang.jiejun@outlook.com人生目标：每天进步一点点 "},"src/golang/":{"url":"src/golang/","title":"golang","keywords":"","body":"golang   Go是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。 语言特色： 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 目录 slice底层原理 map底层原理 "},"src/golang/slice.html":{"url":"src/golang/slice.html","title":"slice底层原理","keywords":"","body":"slice底层原理 slice是什么？ 切片(slice)是 Golang 中一种比较特殊的数据结构，这种数据结构更便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片(slice)是可以看做是一个长度可变的数组。切片(slice)自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片(slice)是对数组一个连续片段的引用，所以切片是一个引用类型。 slice的数据结构   切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。   切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。 slice数据结构定义： type slice struct { array unsafe.Pointer len int cap int } slice内存模型：   切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。 创建slice：  make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。 silce := make( []int , 10) //创建一个len为10，cap大于len的切片 silce := make( []int , 0, 10) //创建一个len为0，cap为10的切片 silce := make( []int , 0) //创建一个空切片 var slice []int //创建一个nil切片   nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。   空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片 从 slice 中得到一块内存地址： s := make([]byte, 200) ptr := unsafe.Pointer(&s[0]) 从 Go 的内存地址中构造一个 slice: var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&s1)) 构造一个虚拟的结构体，把 slice 的数据结构拼出来。 当然还有更加直接的方法，在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice: var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) slice扩容原理 扩容原则: 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。 策略源码:  代码在go/src/runtime/slice.go中 func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc(unsafe.Pointer(&et)) racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if et.size == 0 { // 如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报panic了。 if cap doublecap { newcap = cap } else { if old.len maxSliceCap(et.size) { panic(errorString(\"growslice: cap out of range\")) } var p unsafe.Pointer if et.kind&kindNoPointers != 0 { // 在老的切片后面继续扩充容量 p = mallocgc(capmem, nil, false) // 将 lenmem 这个多个 bytes 从 old.array地址 拷贝到 p 的地址处 memmove(p, old.array, lenmem) // 先将 P 地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的 capmem-newlenmem 个 bytes 这块内存初始化。为之后继续 append() 操作腾出空间。 memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // 重新申请新的数组给新切片 // 重新申请 capmen 这个大的内存地址，并且初始化为0值 p = mallocgc(capmem, et, true) if !writeBarrier.enabled { // 如果还不能打开写锁，那么只能把 lenmem 大小的 bytes 字节从 old.array 拷贝到 p 的地址处 memmove(p, old.array, lenmem) } else { // 循环拷贝老的切片的值 for i := uintptr(0); i 注意事项:  扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。  扩容可能是在原来的地址后追加，也可能会生成全新的内存地址。 // 操作这种形式生成的切片非常危险，极易产生bug。 sliceB := sliceA[0:5] 代码示例 示例1:猜猜下面的代码会输出什么： package main import . \"fmt\" func main() { arr := make([]int, 5, 10) for i:=0; i 输出内容： arr:[0 0 10 0 0 0 1 2 100 4], len:10, cap:10, addr:0xc0000b2050 slice:[0 0 10 0 0 0 1 2 100 4], len:10, cap:10, addr:0xc0000b2050 slice2:[0 0 0 0 0 0 1 2 3 4 1000], len:11, cap:20, addr:0xc0000de000 slice3:[0 0 10], len:3, cap:10, addr:0xc0000b2050 slice4:[0 0 10 0 0 0 1 2], len:8, cap:10, addr:0xc0000b2050 Process finished with exit code 0 内存分析: 示例2:猜猜下面的代码会输出什么： package main import . \"fmt\" func main() { type Student struct { Name string Age int Score int } slice1 := []Student{ {\"张三\", 18, 0}, {\"李四\", 20, 0}, {\"王五\", 22, 0}} m := make(map[string]*Student, 0) for _, v := range slice1 { v.Score = 100 m[v.Name] = &v } Println(slice1) for k, v := range m { Println(k, v) } }   变量v为中间变量，可重复利用，对v取地址实际取的是同一个地址。  同样，更改变量v也不会影响到原切片的内容。输出内容： [{张三 18 0} {李四 20 0} {王五 22 0}] 张三 &{王五 22 100} 李四 &{王五 22 100} 王五 &{王五 22 100} Process finished with exit code 0 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/golang/map.html":{"url":"src/golang/map.html","title":"map底层原理","keywords":"","body":"map原理 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/c++/":{"url":"src/c++/","title":"C/C++","keywords":"","body":"C/C++   C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。  C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。  C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。  C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。注意： 使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 语言特色： 封装 抽象 继承 多态 目录 "},"src/python/":{"url":"src/python/","title":"Python","keywords":"","body":"Python   Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。  Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 语言特色： Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 >>> 后直接执行代码。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 目录 "},"src/structure/":{"url":"src/structure/","title":"数据结构","keywords":"","body":"数据结构 "},"src/algorithm/":{"url":"src/algorithm/","title":"常用算法","keywords":"","body":"常用算法 "},"src/algorithm/sort.html":{"url":"src/algorithm/sort.html","title":"排序算法","keywords":"","body":"排序算法 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/linux/":{"url":"src/linux/","title":"Linux常用命令","keywords":"","body":"Linux常用命令 "},"src/linux/grep.html":{"url":"src/linux/grep.html","title":"Linux三剑客","keywords":"","body":"Linux三剑客 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/mysql/":{"url":"src/mysql/","title":"MySql","keywords":"","body":"MySql "},"src/mysql/install.html":{"url":"src/mysql/install.html","title":"MySql安装与使用","keywords":"","body":"MySql安装与使用 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/thrift/":{"url":"src/thrift/","title":"Thrift","keywords":"","body":"Thrift "},"src/thrift/introduction.html":{"url":"src/thrift/introduction.html","title":"Thrift简介","keywords":"","body":"Thrift简介 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/framework/":{"url":"src/framework/","title":"微服务架构","keywords":"","body":"微服务架构 "},"src/framework/microservice.html":{"url":"src/framework/microservice.html","title":"什么是微服务","keywords":"","body":"什么是微服务 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/vmware/":{"url":"src/vmware/","title":"VMware","keywords":"","body":"VMware "},"src/vmware/transmitmode.html":{"url":"src/vmware/transmitmode.html","title":"VMware备份传输模式","keywords":"","body":"VMware备份传输模式 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/github/":{"url":"src/github/","title":"git","keywords":"","body":"git "},"src/github/function.html":{"url":"src/github/function.html","title":"git使用方法","keywords":"","body":"git使用方法 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"src/github/question.html":{"url":"src/github/question.html","title":"git常见问题","keywords":"","body":"git常见问题 ...未完待续... var gitalk = new Gitalk({ \"clientID\": \"44d7c96f948be236a8c9\", \"clientSecret\": \"fb9fb3178db6640131c4e3eb69f9449e42bba661\", \"repo\": \"blog\", \"owner\": \"Zhang-jie-jun\", \"admin\": [\"Zhang-jie-jun\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "}}